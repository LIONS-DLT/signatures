@using ElectronicSignatureService.Entities

@model Document

@*
    For more information on enabling MVC for empty projects, visit https://go.microsoft.com/fwlink/?LinkID=397860
*@
@{
    int slot = (int)ViewData["slot"]!;
}

<div class="row">
    <div class="col-lg-8 offset-lg-2">
        <input id="file" type="file" onchange="onFileChanged(this)" style="display:none" />
        <h2>@Strings.Label_Document - @Model.Name</h2>
        <div>
            <div><small><b>@Strings.Label_ID:</b> @Model.ID</small></div>
            <div><small><b>@Strings.Label_Filename:</b> @Model.Filename</small></div>
            <div><small><b>@Strings.Label_Hash:</b> @Model.HashCode</small></div>
            <div><small><b>@Strings.Label_Timestamp:</b> @Model.TimeStamp.ToString()</small></div>
        </div>
        <br />
        <div>
            <button class="btn btn-sm btn-outline-primary" onclick="$('#file').trigger('click')">@Strings.Label_CheckFileValidity</button>
        </div>
        <br />
        <h3>@Strings.Label_Signature #@slot</h3>
        <br />
        <div id="formcontainer">
            <div>
                <button type="button" class="btn btn-lg btn-primary w-100" onclick="$('#formcontainer').load('@Url.Action("SelectMethod","Signature")')">@Strings.Label_Sign</button>
            </div>
        </div>
    </div>
</div>

@section Scripts
{
    <script src="~/js/sign.js?version=1"></script>

    <script>

        function checkHashCode(filename, hash) {
            
            if(hash == '@Model.HashCode'){
                alert('OK.\nThe fingerprint of the file is valid.');
            }
            else {
                alert('WARNING!\nThe fingerprint of the file is NOT the same since document registration!');
            }
        }

        function _arrayBufferToBase64(buffer) {
            var binary = '';
            var bytes = new Uint8Array(buffer);
            var len = bytes.byteLength;
            for (var i = 0; i < len; i++) {
                binary += String.fromCharCode(bytes[i]);
            }
            return window.btoa(binary);
        }

        async function getFileHash(data) {
            const hashBuffer = await crypto.subtle.digest('SHA-256', data);
            return _arrayBufferToBase64(hashBuffer).replaceAll('+', '-').replaceAll('/', '_').replaceAll("=", "");
            //const hashArray = Array.from(new Uint8Array(hashBuffer));
            //const hashHex = hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
            //return hashHex;
        }

        function onFileChanged(input) {
            var file = input.files[0];
            var reader = new FileReader();
            reader.onload = (function (f) {
                $('#filename').html(f.name);
                return function (e) {
                    getFileHash(e.target.result).then(hashHex => checkHashCode(f.name, hashHex));
                };
            })(file);

            reader.readAsArrayBuffer(file);
        }
    </script>
}